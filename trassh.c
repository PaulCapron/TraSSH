/**
 * trassh: a fake SSH server that wastes the time of h4cking b0ts.
 * It sends the content of stdin to each client that connects, one at a time.
 * That content is supposedly a bogus SSH handshake, generated by packcraft.pl
 *
 * Author: Paul <paul@fragara.com>
 * Created: 2020¬†AD
 * SPDX-License-Identifier: CC0-1.0
 *  The author has dedicated all rights to this software to the public domain.
 *  This software is distributed without any warranty.
 */
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <errno.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>

#ifndef MIN_SEG_SIZE
#define MIN_SEG_SIZE 1000
/* Deny clients advertizing a TCP maximum segment size (MSS) lower than that.
   These are port scanners which are going to close the connection early anyway.
   Don‚Äôt waste any processing & bandwidth on them. */
#endif

#ifndef TOT_SLEEP_DURA
#define TOT_SLEEP_DURA 2
/* Total sleep duration per round/client, in seconds. Normally split in two:
     ‚Äî one pause after first send(), before client banner recv();
     ‚Äî another before close().
   But the two get coalesced if sent data fit in a single TCP segment. */
#endif

#ifndef LISTEN_FD
#define LISTEN_FD 3  /* File descriptor of the inherited socket */
#endif

static const unsigned BANNER_MAXLEN = 255;  /* Per RFC¬†4253 ¬ß¬†4.2 */

enum log_level {
	LOG_ERR = '3',
	LOG_WARNING,
	LOG_NOTICE,
	LOG_INFO
};  /* See https://www.FreeDesktop.org/software/systemd/man/sd-daemon.html */

static size_t
utoa(unsigned long num, unsigned radix, char *dst, size_t dstcapacity)
{
	unsigned long n;
	size_t len, i;

	for (n = num, len = 1; n > radix-1; n /= radix, len++)  /* count digits */
		;

	if (len > dstcapacity)
		return 0;

	i = len - 1;
	do {  /* write, from right to left (least to most significant digit) */
		char d;

		d = num % radix;
		num /= radix;
		dst[i--] = (d < 10) ? ('0' + d) : ('a' + d - 10);
	} while (num > 0);

	return len;
}

static char Buf[1024];  /* vsay() appends to it, flush() write() it to stdout */
static size_t I;        /* current position in Buf */

static void
flush(void)
{
	write(STDOUT_FILENO, Buf, I);
	I = 0;
}

static void
vsay(enum log_level severity, const char *fmt, va_list ap)
{
	size_t i;

	if (I >= sizeof Buf - 3)
		flush();

	Buf[I++] = '<';
	Buf[I++] = severity;
	Buf[I++] = '>';

	for (i = 0; fmt[i] != '\0' && I < sizeof Buf;) {
		unsigned long n;
		char *s;
		size_t slen;

		if (fmt[i] != '%') {
			Buf[I++] = fmt[i++];
			continue;
		}
		switch (fmt[++i]) {
		case 'm':  /* non-standard but common, GCC & Clang recognize %m */
		case 's':
			s = (fmt[i] == 'm') ? strerror(errno) : va_arg(ap, char *);
			slen = strlen(s);
			if (slen <= sizeof Buf - I) {
				memcpy(Buf + I, s, slen);
				I += slen;
			}
			i++;
			break;
		case 'l':
		case 'u':
		case 'x':
			if (fmt[i] == 'l') {
				i++;
				if (fmt[i] == '\0')
					break;
				n = va_arg(ap, unsigned long);
			} else
				n = va_arg(ap, unsigned);
			I += utoa(n, (fmt[i] == 'x') ? 16 : 10, Buf + I, sizeof Buf - I);
			i++;
			break;
		default:
			;  /* not implemented! */
		}
	}

	if (I < sizeof Buf)
		Buf[I++] = '\n';
}

static void __attribute__((format(printf, 2, 3)))
say(enum log_level severity, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsay(severity, fmt, ap);
	va_end(ap);
}

static void __attribute__((cold, format(printf, 1, 2)))
warn(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsay(LOG_WARNING, fmt, ap);
	va_end(ap);
}

static void __attribute__((noreturn, cold, format(printf, 1, 2)))
die(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsay(LOG_ERR, fmt, ap);
	va_end(ap);
	flush();
	_exit(1);
}

int
main(void)
{
	char *dat;
	size_t datlen;

	/* Make sure stdout is open; fd #1 must not be reused for the client
	 * socket, or else it would also get log messages!
	 * (Testing by means of fcntl() would yield less false negatives,
	 * but let‚Äôs not add to the list of required syscalls.)
	 */
	if (write(STDOUT_FILENO, "", 0) == -1) {
		static const char msg[] = "write(stdout, 0¬†bytes) failed: ";
		char *err = strerror(errno);

		write(STDERR_FILENO, msg, sizeof msg - 1);
		write(STDERR_FILENO, err, strlen(err));
		write(STDERR_FILENO, "\n", 1);
		_exit(1);
	}

	/* Get stdin filesize: */
	{
		struct stat s;

		if (fstat(STDIN_FILENO, &s) == -1)
			die("fstat(stdin) failed: %m");
		if (!S_ISREG(s.st_mode))
			die("stdin is not a regular file");

		datlen = s.st_size;
		say(LOG_INFO, "stdin is %lu bytes long.", datlen);
	}

	/* Map stdin content into memory: */
	dat = mmap(NULL, datlen, PROT_READ, MAP_SHARED, STDIN_FILENO, 0);
	if (dat == MAP_FAILED)
		die("mmap(stdin) failed: %m");

	/*
	 * End the TCP communication with RST, not graceful FIN, when closing
	 * the _client_ socket (it will inherit the SO_LINGER setting):
	 */
	{
		struct linger lg;

		lg.l_onoff = 1;
		lg.l_linger = 0;
		if (setsockopt(LISTEN_FD, SOL_SOCKET, SO_LINGER, &lg, sizeof lg) == -1)
			die("setsockopt(SO_LINGER) failed: %m");
	}

	for (;;) {
		int fd;
		char *datptr;
		size_t fstsegsiz, datremain, sleepremain = TOT_SLEEP_DURA;

		flush();

		/*
		 * Accept client verbosely, and, given its MSS, see how to optimally
		 * TCP-pack the data to send (use least amount of packets, mainly.)
		 */
		{
			struct sockaddr_storage addr;
			unsigned char *ip;
			unsigned mss;
			socklen_t addrlen = sizeof addr;
			socklen_t msslen = sizeof mss;

			fd = accept(LISTEN_FD, (struct sockaddr *)&addr, &addrlen);
			if (fd == -1)
				die("accept() failed: %m");

			if (addr.ss_family != AF_INET && addr.ss_family != AF_INET6) {
				warn("Connection, unknown address family #%u", addr.ss_family);
				fstsegsiz = datlen;
				goto first_send;
			}

			if (getsockopt(fd, IPPROTO_TCP, TCP_MAXSEG, &mss, &msslen) == -1)
				die("getsockopt(TCP_MAXSEG) failed: %m");

			switch (addr.ss_family) {
			case AF_INET:
				ip = (unsigned char *)&((struct sockaddr_in *)&addr)->sin_addr;
			print_ipv4:
				say(LOG_NOTICE, "Connection from %u.%u.%u.%u (MSS: %u)",
					ip[0], ip[1], ip[2], ip[3], mss);
				break;
			case AF_INET6:
				ip = (unsigned char *)&((struct sockaddr_in6 *)&addr)->sin6_addr;
				if (memcmp(ip, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12) == 0) {
					/* IPv4-mapped address (see RFC¬†5952 ¬ß¬†5). */
					ip += 12;
					goto print_ipv4;
				}
				say(LOG_NOTICE,
					"Connection from %x:%x:%x:%x:%x:%x:%x:%x (MSS: %u)",
					(ip[ 0]<<8)+ip[ 1], (ip[ 2]<<8)+ip[ 3],
					(ip[ 4]<<8)+ip[ 5], (ip[ 6]<<8)+ip[ 7],
					(ip[ 8]<<8)+ip[ 9], (ip[10]<<8)+ip[11],
					(ip[12]<<8)+ip[13], (ip[14]<<8)+ip[15], mss);
				/* This doesn‚Äôt shorten the longest run of ‚Äò0:‚Äô to ‚Äò::‚Äô üòë */
				break;
			}

			if (mss < MIN_SEG_SIZE) {
				warn("‚îú client MSS (%u) smaller than acceptable minimum (%u)",
					 mss, MIN_SEG_SIZE);
				goto end;
			}

			/* Make the first segment the smallest: some clients disconnect
			   after getting it. (They first quickly probe for a responding
			   SSH peer, and only then come back to play the game for real.) */
			fstsegsiz = datlen % mss;
			if (fstsegsiz == 0)
				fstsegsiz = mss;
			else if (fstsegsiz < BANNER_MAXLEN+1 && datlen > BANNER_MAXLEN+1)
				fstsegsiz = BANNER_MAXLEN+1;  /* +1 to ‚Äúround‚Äù to 256 */
		}

		/*
		 * Send first part of data:
		 */
	first_send: {
			ssize_t sent;

			sent = send(fd, dat, fstsegsiz, MSG_NOSIGNAL|MSG_DONTWAIT);
			if (sent < 1) {
				if (errno == EFAULT)
					die("‚îî send(%lu bytes) failed: %m", fstsegsiz);
				warn("‚îú send(%lu bytes) failed: %m", fstsegsiz);
				goto end;
			}

			datptr = dat + sent;
			datremain = datlen - sent;
			say(LOG_INFO, "‚îú sent %lu bytes, %lu remaining", sent, datremain);
		}

		/*
		 * Rest for a while; give the client time to send its banner:
		 */
		flush();
		{
			unsigned dur;

			dur = (datremain > 0) ? (TOT_SLEEP_DURA / 2) : TOT_SLEEP_DURA;
			sleepremain -= dur;
			if ((dur = sleep(dur)) > 0) {
				warn("‚îú sleep() interrupted");
				sleepremain += dur;
			}
		}

		/*
		 * Read client banner:
		 */
		{
			char buf[2048];	 /* oversized, to see if client also sent KEXINIT */
			ssize_t got;
			char *eol;

			got = recv(fd, buf, sizeof buf, MSG_NOSIGNAL|MSG_DONTWAIT);
			if (got == -1) {
				warn("‚îú recv() failed: %m");
				goto end;
			}

			if (got < 10
				|| memcmp(buf, "SSH-", 4) != 0
				|| (eol = memchr(buf + 4, '\n', BANNER_MAXLEN)) == NULL) {
				warn("‚îú received %lu bytes, no banner inside", got);
				goto end;
			}

			if (*(eol - 1) == '\r')
				--eol;
			*eol = '\0';

			/* ‚ö† Client banner is hardly sanitized (think terminal escape
			   sequences). Pipe stdout to a decent logger! */
			say(LOG_INFO, "‚îú received %lu bytes, banner: %s", got, buf);
		 }

		/*
		 * Send rest of data:
		 */
		for (; datremain > 0;) {
			ssize_t sent;

			sent = send(fd, datptr, datremain, MSG_NOSIGNAL|MSG_DONTWAIT);
			if (sent < 1) {
				if (errno == EFAULT)
					die("‚îî send(%lu bytes) failed: %m", fstsegsiz);
				warn("‚îú send(%lu bytes) failed: %m", datremain);
				break;
			}

			datptr += sent;
			datremain -= sent;
			say(LOG_INFO, "‚îú sent %lu bytes, %lu remaining", sent, datremain);
		}

	end:
		flush();

		if (sleepremain > 0 && sleep(sleepremain) > 0)
			warn("‚îú sleep() interrupted");

		if (close(fd) == -1)
			warn("‚îî close() failed: %m");
		else
			say(LOG_INFO, "‚îî connection closed.");
	}
}
